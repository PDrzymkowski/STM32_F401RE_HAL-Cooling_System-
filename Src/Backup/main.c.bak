/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  ** This notice applies to any and all portions of this file
  * that are not between comment pairs USER CODE BEGIN and
  * USER CODE END. Other portions of this file, whether 
  * inserted by the user or by software development tools
  * are owned by their respective copyright owners.
  *
  * COPYRIGHT(c) 2018 STMicroelectronics
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
	*/
	
	
	/*! \mainpage Projekt PMIK 18Z: Uklad chlodzacy
 *
 * \section 	  Opis
 *
 * Projekt jest ukladem chlodzacym ktorego dzialanie opiera sie na pomiarze temperatury
 * odpowiednim czujnikiem i na podstawie wynikow uruchomienie wiatraczkow chlodzacych.
 * <br> Uklad komunikuje sie z uzytkownikiem przy uzyciu wyswietlacza LCD oraz zestawu
 * przyciskow, jak rowniez za posrednictwem UART z komputerem.<br> Uzytkownik ma wplyw na 
 * tryb pomiaru okreslonym urzadzeniem, jak rowniez na moc pracy wiatraczkow oraz wartosc
 * temperatury granicznej.<br>
 * Dzialanie programu zaimpementowane zostalo przy uzyciu mikrokontrolera STM32, aplikacja
 * zas napisana w jezyku C.
 *
 * \section Peryferia
 *	Mikrokontroler STM32 F401RB<br>
 *	Termometr cyfrowy DS18B20<br>
 *	Termometr analogowy LM35<br>
 *	Wyswietlacz LCD RG1602A<br>
 *	2 Wiatraczki 5V firmy Sunon<br>
 *  Modul karty SD<br>
 *	Zestaw 4 przyciskow typu "tact-switch"<br>
 *	Mostek H do zasilania wiatrakow<br>
 *	Kasetka baterii do zasilania ukladu
 *
 *  \section Plik Main:
 *  Szczegolowy opis programu mozna znalezc w czesci opisujacej plik main.c <br>
 *
 * \section Projekt Wykonali:
 *  Piotr Drzymkowski<br>
 *  Borys Khachapuridze
 *
 
 */
  
	/* USER CODE END Header */


/* Includes ------------------------------------------------------------------*/
#include "main.h"
/** \brief Plik zawierajacy obsluge systemu plikow fatfs wymaganego do obslugi modulu kart SD */
#include "fatfs.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
/** \brief Plik zawierajacy funkcje opozniajaca delay() uzywana w peryferiach ukladu */
#include "Delay.h"
/** \brief Plik zawierajacy obsluge termometru cyfrowego DS18B20 poprzez interfejs 1-wire*/
#include "DS18B20.h"
/** \brief Plik zawierajacy obsluge wyswietlacza LCD*/
#include "LCD_RG1602A.h"
#include "lcd.h"
#include <string.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/** \brief Minimalny tryb pracy wiatraka okreslany jako wypelnienie sygnalu PWM */
#define FANSPEEDLOW 700
/** \brief Sredni tryb pracy wiatraka okreslany jako wypelnienie sygnalu PWM */
#define FANSPEEDMEDIUM 850 
/** \brief Maksymalny tryb pracy wiatraka okreslany jako wypelnienie sygnalu PWM */
#define FANSPEEDHIGH 999
/** \brief Minimalna wartosc temepratury krytycznej jaka moze przyjac uklad */
#define TEMPERATURE_MIN 0
/** \brief Maksymalna wartosc temepratury krytycznej jaka moze przyjac uklad */
#define TEMPERATURE_MAX 70

/** \brief Tryb pracy ukladu jako pomiar rdzenia wewnetrznym czunikiem mikrokontrolera */
#define CORE 0
/** \brief Tryb pracy ukladu jako pomiar analogowym termometrem LM35*/
#define LM35 1
/** \brief Tryb pracy ukladu jako pomiar cyfrowym termometrem DS18B20 */
#define DS18B20 2

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

RTC_HandleTypeDef hrtc;

SPI_HandleTypeDef hspi2;

TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;
TIM_HandleTypeDef htim5;
TIM_HandleTypeDef htim9;

UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */
volatile uint16_t handler_zmienna = 0;
/** \brief Flaga okreslajaca czy zakonczono proces "debouncingu" dla przycisku Switch0 */
volatile uint8_t FLAG_SWITCH0_DEBOUNCING = 0; 
/** \brief Flaga okreslajaca czy zakonczono proces "debouncingu" dla przycisku Switch1 */
volatile uint8_t FLAG_SWITCH1_DEBOUNCING = 0;
/** \brief Flaga okreslajaca czy zakonczono proces "debouncingu" dla przycisku Switch2 */
volatile uint8_t FLAG_SWITCH2_DEBOUNCING = 0; 
/** \brief Flaga okreslajaca czy zakonczono proces "debouncingu" dla przycisku Switch3 */
volatile uint8_t FLAG_SWITCH3_DEBOUNCING = 0;
/** \brief Flaga okreslajaca czy nalezy dokonac pomiaru temperatury */
uint8_t FLAG_START_TEMPERATURE_MEASUREMENT = 0;
/** \brief Flaga okreslajaca czy przekroczono temeprature krytyczna i nalezy uruchomic wiatrak */
uint8_t FLAG_OVER_CRITICAL_TEMPERATURE = 0;
/** \brief Flaga okreslajaca czy nalezy zapisac w danym momencie dane na karcie SD*/
uint8_t FLAG_WRITE_SD = 0;
/** \brief Flaga okreslajaca czy karta SD zostala poprawnie wykryta i znajduje sie na niej wystarczajaco miejsca*/
uint8_t FLAG_SD_SPACE_VALID = 0;
/** \brief Flaga okreslajaca stan pracy wiatraczka 1*/
uint8_t FLAG_FAN_1_WORK =0;
/** \brief Flaga okreslajaca stan pracy wiatraczka 2*/
uint8_t FLAG_FAN_2_WORK=0;
volatile uint32_t timer_counter = 0;
/** \brief Tablica przechowujaca pomiary z przetwornika ADC */
volatile uint32_t MeasurementADC[2] = {0};
volatile uint32_t Measurement_0 = 0;
volatile uint32_t Measurement_1 = 0;
volatile uint32_t Measurement_2 = 0;
volatile double Measurement_3 = 0;
/** \brief Wartosc zmierzonej i przeliczonej temperatury przez termometr LM35*/
volatile double Measurement_LM35 = 0;
/** \brief Wartosc zmierzonej i przeliczonej temperatury przez termometr DS18B20*/
volatile double Measurement_DS18B20 = 0;
/** \brief Wartosc zmierzonej i przeliczonej temperatury przez wewnetrzny czujnik STM*/
volatile double Measurement_CORE = 0;
/** \brief Zmienna okreslajaca ilosc sekund ktore minely od ostatniego pomiaru */
uint32_t seconds_counter = 0;
uint32_t sd_card_write_counter = 0;
/** \brief Okres, co ktory ma nastepowac pomiar */
uint32_t measurement_period = 0;
uint32_t sd_card_write_period = 0;//BORYS
/** \brief Tryb pomiaru urzadzenia */
uint8_t measurement_state = CORE;
/** \brief Tryb pracy wiatraka*/
uint16_t fan_speed = FANSPEEDLOW;
volatile uint32_t argument;
/** \brief Tablica znakow reprezentujaca bufor danych wysylanych poprzez UART */
char UART_BUFFER[100];
/** \brief Rozmiar bufora danych wysylanych poprzez UART */
volatile uint16_t UART_BUFFER_SIZE = 0; 
/** \brief Tablica znakow reprezentujaca bufor danych wysylanych do wyswietlacza LCD */
char LCD_BUFFER[50];
/** \brief Tablica znakow reprezentujaca bufor danych wysylanych do karty SD */
char SD_BUFFER[250];
/** \brief Rozmiar bufora danych wysylanych do wyswietlacza LCD */
volatile uint16_t LCD_BUFFER_SIZE = 0;

/** \brief Wartosc temperaturey krytycznej ukladu */
uint32_t critical_temp = 25;
/** \brief Tablica znakow przechowujaca obecna wartosc gornej linii tekstu wyswietlanego na LCD */
char LCD_upper_line [16];
/** \brief Tablica znakow przechowujaca obecna wartosc dolnej linii tekstu wyswietlanego na LCD */
char LCD_lower_line [16];

//Fatfs object
FATFS FatFs;
//File object
FIL fil;
//SD space variables
uint32_t total_space, free_space;

int i_index = 0;
int presence = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_RTC_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM3_Init(void);
static void MX_TIM1_Init(void);
static void MX_ADC1_Init(void);
static void MX_TIM4_Init(void);
static void MX_TIM5_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_SPI2_Init(void);
static void MX_TIM9_Init(void);
/* USER CODE BEGIN PFP */
void SetFanState(void);
void UpdateFan(void);
/**
****************************************************************************************
* @brief 			Zmiana trybu pomiaru: CORE->LM35->DS18B20 <br><br>
*							Wywolywana w momencie wcisniecia przycisku Switch 0.
*	
* @param 			Brak
*	@return			Brak
****************************************************************************************
*/
void CycleMeasurementState(){
	
	if(measurement_state == CORE)
  {
		measurement_state = LM35;
	}else if(measurement_state == LM35)
	{
		measurement_state=DS18B20;
	}else
	{
		measurement_state = CORE;
	}
}

/**
****************************************************************************************
* @brief 			Zmiana trybu mocy wiatraka: niska->srednia->duza. <br><br>
*							Wywolywana w momencie wcisniecia przycisku Switch 1.
*	
* @param 			Brak
*	@return			Brak
****************************************************************************************
*/
void CycleFanState(){
	
	if(fan_speed == FANSPEEDLOW)
  {
		fan_speed = FANSPEEDMEDIUM;
	}else if(fan_speed  == FANSPEEDMEDIUM)
	{
		fan_speed=FANSPEEDHIGH;
	}else
	{
		fan_speed = FANSPEEDLOW;
	}
}

/**
****************************************************************************************
* @brief 			Matematyczne przeliczenie wartosci zmierzonej przez wewnetrzny czujnik
*							temperatury rdzenia mikrokontrolera na konkretna wartosc temperatury na 
*							podstawie zadanego wzoru.
*	
* @param 			uint32_t temperature: wartosc zmierzona przez czunik rdzenia
*	@return			(double) : wartosc temperatury 
****************************************************************************************
*/
double TemperatureConversion_CORE(uint32_t temperature)
{
	double temp=temperature;
	temp=((temp*3.3/4095-0.76)/0.0025+25);
	if ((uint32_t)temp >=255) return 0;
	else return temp;
}

/**
****************************************************************************************
* @brief 			Matematyczne przeliczenie wartosci zmierzonej przez temrometr LM35 na
*							konkretna wartosc temperatury na podstawie zadanego wzoru.
*	
* @param 			uint32_t temperature: wartosc zmierzona przez termometr LM35
*	@return			(double) : wartosc temperatury 
****************************************************************************************
*/
double TemperatureConversion_LM35(uint32_t temperature)
{
	double temp=temperature;	
	return ((temp*3.3/4095)/0.01);//10 mv/degC
}

/**
****************************************************************************************
* @brief 			Wlaczenie timera htim1 celem opoznienia odczytu wartosci przycisku, 
*							ktory przez pierwsza, krotka chwile jest niepewny w wyniku zjawiska
*							"bouncingu". <br><br>
*							Wywolywana dla odpowiedniego pinu przypisanego do switcha zglaszajacego
*							przerwanie.<br>
*	
* @param 			uint16_t GPIO_Pin: okresla pin, do ktorego przypisany jest switch
*	@return			Brak
****************************************************************************************
*/

void SwitchDebouncing(uint16_t GPIO_Pin){
		
	switch(GPIO_Pin){
		
		case SWITCH_0_Pin:	
		if(FLAG_SWITCH0_DEBOUNCING == 0)
			{
				HAL_TIM_Base_Start_IT(&htim1);
				HAL_NVIC_DisableIRQ(EXTI0_IRQn);
				FLAG_SWITCH0_DEBOUNCING = 1;
			}
			break;
		case SWITCH_1_Pin:
		if(FLAG_SWITCH1_DEBOUNCING == 0)
			{
				HAL_TIM_Base_Start_IT(&htim1);
				HAL_NVIC_DisableIRQ(EXTI1_IRQn);
				FLAG_SWITCH1_DEBOUNCING = 1;
			}
			break;
				case SWITCH_2_Pin:	
		if(FLAG_SWITCH2_DEBOUNCING == 0)
			{
				HAL_TIM_Base_Start_IT(&htim1);
				HAL_NVIC_DisableIRQ(EXTI2_IRQn);
				FLAG_SWITCH2_DEBOUNCING = 1;
			}
			break;
		case SWITCH_3_Pin:
		if(FLAG_SWITCH3_DEBOUNCING == 0)
			{
				HAL_TIM_Base_Start_IT(&htim1);
				HAL_NVIC_DisableIRQ(EXTI3_IRQn);
				FLAG_SWITCH3_DEBOUNCING = 1;
			}
			break;
			
		}
}

/**
********************************************************************************************
* @brief 			Obsluga wyswietlania na ekranie LCD 16x2. <br>
*							Funkcja ta dokonuje wyczyszczenia zawartosci wyswietlacza i wpisania linii
*							tekstu gornej i dolnej czesci ekranu. W przypadku zmiany parametru gornej linii
*							(np. trybu pomiaru) nastepuje odpowiednia aktualizacja zmiennej LCD_upper_line 
*							i jej wyswietlenie poprzez funkcje LCD_String. Dolna linijka jest wtedy 
*							zapamietana w zmiennej LCD_lower_line i rowniez wyswietlona. W przypadku zmiany
* 						parametrow dolnej linii dzieje sie analogicznie.
*							
*	
* @param 			uint8_t mode: dla 0- nadpisanie gornej linii ekranu, dla 1- dolnej linii
*	@return			Brak
********************************************************************************************
*/
void UpdateLCD(uint8_t mode)
{
		LCD_Cls();
	if(mode==0){			
		LCD_Locate(0,0);
		if(measurement_state == CORE)
				sprintf(LCD_BUFFER,"CORE: %d", (uint32_t)Measurement_CORE);
		if(measurement_state==LM35)
				sprintf(LCD_BUFFER,"LM35: %d", (uint32_t)Measurement_LM35);
		if(measurement_state==DS18B20)
				sprintf(LCD_BUFFER,"DS18: %d", (uint32_t)Measurement_DS18B20);
		
		if(FLAG_OVER_CRITICAL_TEMPERATURE == 1)
				strcat(LCD_BUFFER, "|ON");
		
		LCD_String(LCD_BUFFER);
			//sprintf(LCD_BUFFER,"%s", LCD_upper_line);
			sprintf(LCD_upper_line,"%s", LCD_BUFFER);
		LCD_Locate(0,1);
			sprintf(LCD_BUFFER,"%s",LCD_lower_line);
		LCD_String(LCD_BUFFER);
		
	}else if(mode==1){
		LCD_Locate(0,0);
		sprintf(LCD_BUFFER,"%s",LCD_upper_line);
		LCD_String(LCD_BUFFER);
		LCD_Locate(0,1);
			if(fan_speed==FANSPEEDLOW)
					sprintf(LCD_BUFFER,"Kryt:%d|Tryb:0",critical_temp);
			else if(fan_speed==FANSPEEDMEDIUM)
					sprintf(LCD_BUFFER,"Kryt:%d|Tryb:1",critical_temp);
			else if(fan_speed==FANSPEEDHIGH)
					sprintf(LCD_BUFFER,"Kryt:%d|Tryb:2",critical_temp);
		LCD_String(LCD_BUFFER);
			sprintf(LCD_lower_line,"%s", LCD_BUFFER);
	}
}


/**
********************************************************************************************
* @brief 			Wywolanie funkcji SwitchDebouncing w momencie zgloszenia przerwania przez
*							ktorys switch
*	
* @param 			uint16_t GPIO_Pin: okresla pin przycisku, ktory zglasza przerwanie
*	@return			Brak
********************************************************************************************
*/

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){
	
		//if(HAL_GPIO_ReadPin(SWITCH_0_GPIO_Port, GPIO_Pin)==GPIO_PIN_SET)
		//HAL_GPIO_TogglePin(DIODA_GPIO_Port,DIODA_Pin);
		//handler_zmienna=handler_zmienna+1;
		SwitchDebouncing(GPIO_Pin);
}


/**
********************************************************************************************
* @brief 			Zmiana wartosci temperatury krytycznej o 1 w gore lub w dol przy obsludze
*							przyciskami w okreslonym dla programu zakresie.<br><br>
*							Switch 2: wzrost o 1
*							Switch 3: spadek o 1
*	
* @param 			uint8_t mode: dla 0- zwiekszenie temp. krytycznej o 1; dla 1- zmniejszenie o 1
*	@return			Brak
********************************************************************************************
*/

void ChangeCriticalTemp(uint8_t mode){
	
	
	if(mode == 0)
		if(critical_temp <= TEMPERATURE_MAX+1)
		{
			critical_temp += 1; 
		}
	
	if(mode == 1)
		if(critical_temp >= TEMPERATURE_MIN+1)
		{
			critical_temp -= 1;
		}
}

/**
****************************************************************************************
* @brief 			Obsluga akcji wcisniecia klawiszy "switch" (0,1,2,3). <br>
*							Wywolywana za posrednictwem funkcji przerwania HAL_TIM_PeriodElapsedCallback
*	
* @param 			uint16_t GPIO_PIN: okresla konretny pin, ktoremu odpowiada switch
*	@return			Brak
****************************************************************************************
*/

void SwitchAction(uint16_t GPIO_PIN){
	
	switch(GPIO_PIN)
	{
	
		//Switch zmieniajacy tryb pomiaru CORE->LM35->DS18B20

		case SWITCH_0_Pin:
		//	HAL_GPIO_TogglePin(DIODA_GPIO_Port,DIODA_Pin);
		//	handler_zmienna=handler_zmienna+1;	
			CycleMeasurementState();
			UpdateLCD(0);
			break;
	
		//	Switch zmieniajacy tryb pracy wiatraczka LOW->MEDIUM->HIGH

		case SWITCH_1_Pin:
		//handler_zmienna=handler_zmienna+1;
			CycleFanState();
			UpdateLCD(1);
			break;
		

		//	Switch zwiekszajacy temp. krytyczna o 1 stopien

		case SWITCH_2_Pin:
			ChangeCriticalTemp(0);
			UpdateLCD(1);
			break;
	
		//	Switch zmniejszajacy temp. krytyczna o 1 stopien

		case SWITCH_3_Pin:
			ChangeCriticalTemp(1);
			UpdateLCD(1);
			break;
	}
	
}

/**
****************************************************************************************
* @brief 			Funkcja obslugi przerwania licznikow. Wywolywana w przypadku wykonania
*							funkcji SwitchDebouncing. <br>W odpowiednich instrukcjach warunkowych sprawdzany
*							jest licznik zglaszajacy przerwanie i wykonywana obsluga: switchy
*							(funkcja SwitchAction) wraz ze zdjeciem flagi "DEBOUNCING"; karty SD;
*							pomiaru temperatury.<br> Do kazdego z tych zdarzen przypisany jest odpowiedni
*							timer
*	
* @param 			TIM_HandleTypeDef *htim: wskaznik na okreslony licznik zglaszajacy 
*							przerwanie, czyli doliczenie do konca
*	@return			Brak
****************************************************************************************
*/


void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
		
		if(htim->Instance == TIM1)
		{
			HAL_NVIC_EnableIRQ(EXTI0_IRQn);
			HAL_NVIC_EnableIRQ(EXTI1_IRQn);
			HAL_NVIC_EnableIRQ(EXTI2_IRQn);
			HAL_NVIC_EnableIRQ(EXTI3_IRQn);
			if(HAL_GPIO_ReadPin(SWITCH_0_GPIO_Port, SWITCH_0_Pin) == GPIO_PIN_RESET && FLAG_SWITCH0_DEBOUNCING==1) 
			{
				SwitchAction(SWITCH_0_Pin);
				FLAG_SWITCH0_DEBOUNCING = 0;
			}
			if(HAL_GPIO_ReadPin(SWITCH_1_GPIO_Port, SWITCH_1_Pin) == GPIO_PIN_RESET && FLAG_SWITCH1_DEBOUNCING==1) 
			{
				SwitchAction(SWITCH_1_Pin);
				FLAG_SWITCH1_DEBOUNCING = 0;
			}
			if(HAL_GPIO_ReadPin(SWITCH_2_GPIO_Port, SWITCH_2_Pin) == GPIO_PIN_RESET && FLAG_SWITCH2_DEBOUNCING==1) 
			{
				SwitchAction(SWITCH_2_Pin);
				FLAG_SWITCH2_DEBOUNCING = 0;
			}
			if(HAL_GPIO_ReadPin(SWITCH_3_GPIO_Port, SWITCH_3_Pin) == GPIO_PIN_RESET && FLAG_SWITCH3_DEBOUNCING==1) 
			{
				SwitchAction(SWITCH_3_Pin);
				FLAG_SWITCH3_DEBOUNCING = 0;
			}
			if(FLAG_SWITCH0_DEBOUNCING==0 && FLAG_SWITCH1_DEBOUNCING==0 && FLAG_SWITCH2_DEBOUNCING==0 && FLAG_SWITCH3_DEBOUNCING==0)
			{
			HAL_TIM_Base_Stop_IT(&htim1);
			}
		}
		if(htim->Instance == TIM5)
		{
			seconds_counter++;
			sd_card_write_counter++;
			SetFanState();
			UpdateFan();
			
			if (seconds_counter >= measurement_period)
			{
				seconds_counter = 0;
				FLAG_START_TEMPERATURE_MEASUREMENT = 1;
			}
			if (sd_card_write_counter >= sd_card_write_period)
			{
				sd_card_write_counter = 0;
				FLAG_WRITE_SD = 1;
			}
			
	
}
}

/**
****************************************************************************************
* @brief 			Sprawdzenie, czy dla obecnego trybu pomiaru temepratura nie przekracza
*							krytycznej, ustalonej wartosci. <br> Wartosc zwracana przez funkcje
*							przez funkcje jest przypisywana do flagi FLAG_OVER_CRITICAL_TEMPERATURE, 
*							ktora w funkcj main zglasza odpowiednie przerwanie.
*	
* @param 			Brak
*	@return			(uint8_t) : 0- temperatura ponizej krytycznej; 1- ponad krytyczna
****************************************************************************************
*/
uint8_t IsTempOverCritical()
{
		
		switch(measurement_state)
		{
			case CORE:
				if(Measurement_CORE >= critical_temp)
						return 1;
				break;
			case LM35:
					if(Measurement_LM35 >= critical_temp)
						return 1;
				break;
			case DS18B20:
					if(Measurement_DS18B20 >= critical_temp)
						return 1;
				break;
			
		}
		return 0;
}


/**
****************************************************************************************
* @brief 			Pomiar temperatury odpowiednim sposobem.<br> <br>
*							Funkcja wywolywana jest w przerwaniu, w przypadku, gdy odpowiedni timer
*							je zglosi oraz w okreslonych przypadkach zmian parametrow pomiaru.
*							W przypadku trybu CORE lub LM35 stosujemy pomiar ADC z uzyciem DMA, jego
*							zapis do tablicy MeasurementADC i odpowiednie przypisanie do zmiennych
*							pomiarowych. <br>
*							Pomiar w przerwaniu jest realizowany poprzez sprawdzenie stanu flagi
*							FLAG_START_TEMPERATURE_MEASUREMENT w petl whie funkcji main. Flaga 	
*							ta jest ustalana na wartosc 1, gdy minie okres czasu okreslony zmienna 
*							measurement_period i zerowana na koncu wywolania funkcji.
*							W przypadku pomiaru termometrem cyfrowym DS18B20 wywolywana jest funkcja
*							DS18B20_ReadTemperature, a jej wartosc zwracana przypisywana jest do
*							zmiennej pomiarowej termometru.<br>
*							Po kazdorazowym pomiarze sprawdzane jest, czy temepratura obecna nie
*							przekracza krytycznej jak rowniez nastepuje aktualizacja LCD.<br>
*	
* @param 			Brak
*	@return			Brak
****************************************************************************************
*/

void StartTemperatureMeasurement()
{
			switch(measurement_state)
			{
				case CORE:
				HAL_ADC_Start_DMA(&hadc1, MeasurementADC, sizeof(MeasurementADC)/sizeof(MeasurementADC[0]));
	
				//nie wiem czy to na pewno ten element z tablicy ADC
				Measurement_CORE = (uint32_t)TemperatureConversion_CORE(MeasurementADC[1]);
				
				FLAG_OVER_CRITICAL_TEMPERATURE = IsTempOverCritical();
				break;
				
				case LM35:
				HAL_ADC_Start_DMA(&hadc1, MeasurementADC, sizeof(MeasurementADC)/sizeof(MeasurementADC[0]));
			
				//nie wiem czy to na pewno ten element z tablicy ADC
				Measurement_LM35 = (uint32_t)TemperatureConversion_LM35(MeasurementADC[0]);
				
				FLAG_OVER_CRITICAL_TEMPERATURE = IsTempOverCritical();
					break;
				
				case DS18B20:
						Measurement_DS18B20 = DS18B20_ReadTemperature();
						FLAG_OVER_CRITICAL_TEMPERATURE = IsTempOverCritical();
						break;
			}
			UpdateLCD(0);
			UpdateFan();
			
		FLAG_START_TEMPERATURE_MEASUREMENT = 0;
}


/**
****************************************************************************************
* @brief 			Ustawienie parametrow pracy wiatrakow<br><br>
*							W zaleznosci od zmiennych globalnych measurement_state oraz fan_speed
*							ustawiane sa rejestry CCR1 odpowiednich timerow odpowiedzialnych za sterowanie
*							wiatrakami przy pomocy generacji sygnalu modulowanego PWM o wypelnieniu zaleznym od
*							wartosci rejestrow CCR1.
*							<br>
*							Zmiana wartosci rejestrow nie aktualizuje od razu pracy timerow, wymagane jest wywolanie funkcji
*							UpdateFan()
*							
*	
* @param 			Brak
*	@return			Brak
****************************************************************************************
*/
void SetFanState()
	//TODO W zaleznosci od measurementstate wybieramy wiatrak, oraz jego predkosc zalezna od fanSpeed
{
	
		if(measurement_state == CORE)
		{
			
			switch(fan_speed){
				
				case FANSPEEDLOW:
					htim2.Instance->CCR1 = FANSPEEDLOW;
					break;
				case FANSPEEDMEDIUM:
					htim2.Instance->CCR1 = FANSPEEDMEDIUM;
					break;
				case FANSPEEDHIGH: 
					htim2.Instance->CCR1 = FANSPEEDHIGH;
					break;
				default:
					htim2.Instance->CCR1 = FANSPEEDLOW;
					break;
				
			}
//			if (FLAG_OVER_CRITICAL_TEMPERATURE==1) HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1);
		}
		else if(measurement_state == DS18B20 || measurement_state == LM35)
		{
			switch(fan_speed){
				
				case FANSPEEDLOW:
					htim3.Instance->CCR1 = FANSPEEDLOW;
					break;
				case FANSPEEDMEDIUM:
					htim3.Instance->CCR1 = FANSPEEDMEDIUM;
					break;
				case FANSPEEDHIGH: 
					htim3.Instance->CCR1 = FANSPEEDHIGH;
					break;
				default:
					htim3.Instance->CCR1 = FANSPEEDLOW;
					break;
				
			}
//			HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1);
		}
}

/**
****************************************************************************************
* @brief 			Aktualizacja stanu pracy wiatrakow<br> <br>
*							W zaleznosci od measurement_state wlaczany jest odpowiedni wiatrak, a niewybrany aktualnie wiatrak
*							jest wylaczany<br>
*							Sterowanie wiatrakami odbywa sie przez wlaczenie generacji sygnalu PWM na
*							kanalach pierwszych timerow htim2 lub htim3, w zaleznosci od aktywnego urzadzenia pomiarowego<br>
*							Wlaczenie PWM nastepuje tylko wtedy, gdy pomiar temperatury przekracza wartosc graniczna
*							(flaga FLAG_OVER_CRITICAL_TEMPERATURE rowna 1)<br>
*							Sygnal PWM nie wysterowuje bezposrednio wiatrakow, lecz jest podawany na odpowiednie wejscia
*							modulu sterujacego L293D<br>
*	
* @param 			Brak
*	@return			Brak
****************************************************************************************
*/
void UpdateFan()
{
	/*
		if(measurement_state == CORE)
		{
			
			HAL_TIM_PWM_Stop(&htim3,TIM_CHANNEL_1);
			if (FLAG_OVER_CRITICAL_TEMPERATURE==1)
			{	
				HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1);
			}
			else
			{
				HAL_TIM_PWM_Stop(&htim2,TIM_CHANNEL_1);
			}
		}
//			if (FLAG_OVER_CRITICAL_TEMPERATURE==1) HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1);
		else if(measurement_state == DS18B20 || measurement_state == LM35)
		{
			HAL_TIM_PWM_Stop(&htim2,TIM_CHANNEL_1);
			if (FLAG_OVER_CRITICAL_TEMPERATURE==1)
			{	
				HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_1);
			}
			else
			{
				HAL_TIM_PWM_Stop(&htim3,TIM_CHANNEL_1);
			}
		}
		*/
		if (FLAG_OVER_CRITICAL_TEMPERATURE==1)
		{
			if(measurement_state == CORE)
			{
				if(FLAG_FAN_1_WORK == 0) 
				{
					HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1);
					FLAG_FAN_1_WORK = 1;
				}
				if(FLAG_FAN_2_WORK == 1)
				{
					HAL_TIM_PWM_Stop(&htim3,TIM_CHANNEL_1);
					FLAG_FAN_2_WORK = 0;
				}
			}
			else if(measurement_state == DS18B20 || measurement_state == LM35)
			{
				if(FLAG_FAN_2_WORK == 0) 
				{
					HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_1);
					FLAG_FAN_2_WORK = 1;
				}
				if(FLAG_FAN_1_WORK == 1)
				{
					HAL_TIM_PWM_Stop(&htim2,TIM_CHANNEL_1);
					FLAG_FAN_1_WORK = 0;
				}
			}
		}
		else if (FLAG_OVER_CRITICAL_TEMPERATURE ==0)
		{
			if(FLAG_FAN_1_WORK == 1)
				{
					HAL_TIM_PWM_Stop(&htim2,TIM_CHANNEL_1);
					FLAG_FAN_1_WORK = 0;
				}
				if(FLAG_FAN_2_WORK == 1)
				{
					HAL_TIM_PWM_Stop(&htim3,TIM_CHANNEL_1);
					FLAG_FAN_2_WORK = 0;
				}
		}
}
//BORYS

/**
****************************************************************************************
* @brief 			Sprawdzenie stanu zamontowanego nosnika (karta sd)<br><br>
* 						Wykorzystuje funkcje modulu FATFS do okreslenia liczby wolnych sektorow karty,
*							oraz calkowitej liczby sektorow<br>
*							
*	
* @param 			uint32_t* total : wskaznik na zmienna do ktorej zostanie wpisana liczba wszystkich sektorow
*	@param			uint32_t* free : wskaznik na zmienna do ktorej zostanie wpisana liczba wolnych sektorow
*	@return			(FRESULT) : zmienna typu FRESULT modulu FATFS, w przypadku zwracania wartosci innej niz FR_OK oznacza blad
****************************************************************************************
*/
FRESULT FATFS_DriveSize(uint32_t* total, uint32_t* free) {
	//*	@author		Tilen Majerle
	FATFS *fs;
  DWORD fre_clust;
	FRESULT res;

    /* Get volume information and free clusters of drive */
    res = f_getfree("0:", &fre_clust, &fs);
    if (res != FR_OK) {
		return res;
	}

    /* Get total sectors and free sectors */
    *total = (fs->n_fatent - 2) * fs->csize / 2;
    *free = fre_clust * fs->csize / 2;
	
	/* Return OK */
	return FR_OK;
}

/**
****************************************************************************************
* @brief 			Funkcja konfiguracyjna zwiazana z karta SD<br><br>
*							Funkcja montuje karte SD oraz otwiera (lub tworzy) plik konfiguracyjny, w ktorym przechowywane
*							sa dane o stanie urzadzenia. Sluzy do wczytywania zachowanej konfiguracji po utracie zasilania<br>
*							W przypadku bledu, braku wolnego miejsca lub braku karty SD
*							ustawiana jest flaga FLAG_SD_SPACE_VALID, blokujaca proby interakcji z karta do 
*							momentu ponownego wlaczenia urzadzenia.
*	
* @param 			Brak
*	@return			(FRESULT) : zmienna typu FRESULT modulu FATFS, w przypadku zwracania wartosci innej niz FR_OK oznacza blad
****************************************************************************************
*/
FRESULT FATFS_USER_INIT(void)
{
	FRESULT res;
	//Sproboj zamontowac
//	res=f_mount(&FatFs, "0:", 1);
//	if (res == FR_OK)
//	while (res != FR_OK || tries_index<=10)
//	res=f_mount(&FatFs, "0:", 1);
		res=f_mount(&FatFs, "0:", 1);
	/*
	if(res == FR_NOT_READY)
	{
		HAL_Delay(100);
		f_mount(0, "0:", 1);
		HAL_Delay(100);
		res=f_mount(&FatFs, "0:", 1);
	}
	*/
	if(res == FR_OK)
		{
			//Sproboj otworzyc plik
			if (f_open(&fil, "0:config.txt", FA_OPEN_ALWAYS | FA_READ |FA_WRITE) == FR_OK)
				{
					//Sprawdz dane o klastrach
					if (FATFS_DriveSize(&total_space, &free_space) == FR_OK)
						{
							/* Data for drive size are valid */
							FLAG_SD_SPACE_VALID = 1;
						}
				}
				f_close(&fil);
		}
		f_mount(0, "0:", 1);
		return res;
}
	


/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  Funkcja main aplikacji. <br>
	*					Nastepuje w niej inicjalizacja wszelkich peryferiow, licznikow oraz ustalenie
	*					stanu poczatkowego niektorych zmiennych.
	*					W petli while nastepuje sprawdzenie wartosci flag celem wlaczenia wiatrakow
	* 				czy zapisania danych na karcie SD.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

	
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_RTC_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_TIM1_Init();
  MX_ADC1_Init();
  MX_TIM4_Init();
  MX_TIM5_Init();
  MX_USART1_UART_Init();
  MX_USART2_UART_Init();
  MX_SPI2_Init();
  MX_FATFS_Init();
  MX_TIM9_Init();
  /* USER CODE BEGIN 2 */

 // HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
//	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
	HAL_TIM_Base_Start(&htim4);
	HAL_TIM_Base_Start_IT(&htim5);	
	LCD_Init();
	measurement_period = 3; //seconds
	sd_card_write_period = 10;
	StartTemperatureMeasurement();
	HAL_Delay(5);
	sprintf(LCD_upper_line, "CORE: TRWA...");
	sprintf(LCD_BUFFER,"T_kryt: %d|Tryb: %d",critical_temp, fan_speed);
	UpdateLCD(0);
	UpdateLCD(1);
	FATFS_USER_INIT();
	
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
		if(FLAG_START_TEMPERATURE_MEASUREMENT == 1)
		{
			StartTemperatureMeasurement();
		}
		if(FLAG_SD_SPACE_VALID == 0)
		{
			HAL_GPIO_WritePin(DIODA_GPIO_Port,DIODA_Pin,GPIO_PIN_SET);
		}
		else
		{
			HAL_GPIO_WritePin(DIODA_GPIO_Port,DIODA_Pin,GPIO_PIN_RESET);
		}
//			UART_BUFFER_SIZE=sprintf(UART_BUFFER, "Pomiar LM35, : %.2f\n\r",Measurement_LM35);
//			while(HAL_UART_Transmit_IT(&huart2, (uint8_t*)UART_BUFFER, UART_BUFFER_SIZE) == HAL_BUSY);
		if(FLAG_WRITE_SD ==1 && FLAG_SD_SPACE_VALID ==1)
		{
			UART_BUFFER_SIZE=sprintf(UART_BUFFER, "Proba sd\n\r");
			while(HAL_UART_Transmit_IT(&huart2, (uint8_t*)UART_BUFFER, UART_BUFFER_SIZE) == HAL_BUSY);
			
			if (f_mount(&FatFs, "0:", 1) == FR_OK)
				{
					if (f_open(&fil, "0:log.txt", FA_OPEN_APPEND | FA_READ | FA_WRITE) == FR_OK)
					{
						sprintf(SD_BUFFER,"%s\n\r%s\n\r",LCD_upper_line,LCD_lower_line);
						if (f_puts(SD_BUFFER, &fil) > 0)
							{
								if (FATFS_DriveSize(&total_space, &free_space) != FR_OK)
								{
									FLAG_SD_SPACE_VALID = 0;
								}
								else if(free_space<=0)
								{
									FLAG_SD_SPACE_VALID = 0;
								}
							}
					}
					f_close(&fil);
				}
				else
				{
					FLAG_SD_SPACE_VALID = 0;
				}
				f_mount(0, "0:", 1);
				FLAG_WRITE_SD = 0;
			}
    /* USER CODE END WHILE */
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};

  /**Configure the main internal regulator output voltage 
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
  /**Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 80;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /**Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */
  /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 2;
  hadc1.Init.DMAContinuousRequests = ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }
  /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
  */
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
  */
  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
  sConfig.Rank = 2;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_TimeTypeDef sTime = {0};
  RTC_DateTypeDef sDate = {0};

  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /**Initialize RTC Only 
  */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
  {
    Error_Handler();
  }

  /* USER CODE BEGIN Check_RTC_BKUP */
    
  /* USER CODE END Check_RTC_BKUP */

  /**Initialize RTC and set the Time and Date 
  */
  sTime.Hours = 0x0;
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
  sDate.Month = RTC_MONTH_JANUARY;
  sDate.Date = 0x1;
  sDate.Year = 0x0;

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}

/**
  * @brief SPI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI2_Init(void)
{

  /* USER CODE BEGIN SPI2_Init 0 */

  /* USER CODE END SPI2_Init 0 */

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  /* SPI2 parameter configuration*/
  hspi2.Instance = SPI2;
  hspi2.Init.Mode = SPI_MODE_MASTER;
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */

}

/**
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM1_Init(void)
{

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
  htim1.Init.Prescaler = 16000;
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 250;
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 80;
  htim2.Init.CounterMode = TIM_COUNTERMODE_DOWN;
  htim2.Init.Period = 1000;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 900;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}

/**
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 80;
  htim3.Init.CounterMode = TIM_COUNTERMODE_DOWN;
  htim3.Init.Period = 1000;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 500;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */
  HAL_TIM_MspPostInit(&htim3);

}

/**
  * @brief TIM4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 80;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 65000;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */

}

/**
  * @brief TIM5 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM5_Init(void)
{

  /* USER CODE BEGIN TIM5_Init 0 */

  /* USER CODE END TIM5_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
  htim5.Init.Prescaler = 16000;
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim5.Init.Period = 5000;
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM5_Init 2 */

  /* USER CODE END TIM5_Init 2 */

}

/**
  * @brief TIM9 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM9_Init(void)
{

  /* USER CODE BEGIN TIM9_Init 0 */

  /* USER CODE END TIM9_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};

  /* USER CODE BEGIN TIM9_Init 1 */

  /* USER CODE END TIM9_Init 1 */
  htim9.Instance = TIM9;
  htim9.Init.Prescaler = 16000;
  htim9.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim9.Init.Period = 0;
  htim9.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  if (HAL_TIM_Base_Init(&htim9) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim9, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM9_Init 2 */

  /* USER CODE END TIM9_Init 2 */

}

/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/** 
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, DIODA_Pin|DS18B20_OUTPUT_PIN_Pin|LCD_D4_Pin|LCD_RS_Pin 
                          |LCD_E_Pin|LCD_RW_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI2_SS_GPIO_Port, SPI2_SS_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_D7_GPIO_Port, LCD_D7_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, LCD_D5_Pin|LCD_D6_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : SWITCH_0_Pin SWITCH_1_Pin SWITCH_2_Pin SWITCH_3_Pin */
  GPIO_InitStruct.Pin = SWITCH_0_Pin|SWITCH_1_Pin|SWITCH_2_Pin|SWITCH_3_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pin : SWITCH_4_Pin */
  GPIO_InitStruct.Pin = SWITCH_4_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(SWITCH_4_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : DIODA_Pin LCD_D4_Pin SPI2_SS_Pin LCD_RS_Pin 
                           LCD_E_Pin LCD_RW_Pin */
  GPIO_InitStruct.Pin = DIODA_Pin|LCD_D4_Pin|SPI2_SS_Pin|LCD_RS_Pin 
                          |LCD_E_Pin|LCD_RW_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : DS18B20_INPUT_PIN_Pin */
  GPIO_InitStruct.Pin = DS18B20_INPUT_PIN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(DS18B20_INPUT_PIN_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : DS18B20_OUTPUT_PIN_Pin */
  GPIO_InitStruct.Pin = DS18B20_OUTPUT_PIN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(DS18B20_OUTPUT_PIN_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : LCD_D7_Pin */
  GPIO_InitStruct.Pin = LCD_D7_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LCD_D7_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LCD_D5_Pin LCD_D6_Pin */
  GPIO_InitStruct.Pin = LCD_D5_Pin|LCD_D6_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI0_IRQn);

  HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI1_IRQn);

  HAL_NVIC_SetPriority(EXTI2_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI2_IRQn);

  HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI3_IRQn);

  HAL_NVIC_SetPriority(EXTI4_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI4_IRQn);

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
